<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
    <link rel="stylesheet" href="routescss.css">
</head>
<body>

<div id="mainflex">
    <canvas id="canv" >

    </canvas>
    <div id="mainpanelgrid">
        <div id="mainpanel">
            <img id='arrowdp' src="images/arrowdown.png">        <img id="addroadbtn" src="images/roadicon.png">
        </div>

    </div>
    <div id="leftpanel">
        <div id="innerleftpanel">
            <img id='arrowlp' src="images/arrowleft.png">
            <img class="iconleftpanel" data-allcities="true" src="images/home.png">
            <span class="iconheadersleftpanel">Города Влияния</span>
            <img class="iconleftpanel" data-allroutbtn="true" src="images/mapicon.png">
            <span class="iconheadersleftpanel">Маршруты</span>
        </div>
    </div>
    <div id="avatar">картинка персонажа</div>
    <div id="MAP">картинка персонажа</div>
    <div id="toppanel">картинка персонажа</div>
    <div id="clock"></div>
    <div id="RoutesWindow">
        <h1 id="routwndheader">Мои Маршруты</h1>
        <img src="images/krestikdlyokon.png" id="exitroutwindowbtn">
        <span class="tablerouteheader">Номер поезда</span>
        <span class="tablerouteheader">Откуда</span>
        <span class="tablerouteheader">Куда</span>
        <span class="tablerouteheader">Отправление</span>
        <span class="tablerouteheader">Прибытие</span>


    </div>
</div>
<script type="module">
    import {roaddifinitionclick,camera,volcanoobj3d, traingonormalization,scene,canvas} from "./GameScript.js";
    import * as THREE from './js/three.js-master/build/three.module.js';

    var mouse = new THREE.Vector2();
    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );




    let arrowlp=document.getElementById('arrowlp');
    let innerleftpanel=document.getElementById('innerleftpanel');
    let arrowdp=document.getElementById('arrowdp');
    let mainpanel=document.getElementById('mainpanel');
    let mainflex=document.getElementById('mainflex');
    let citiesbtn=document.querySelector("[data-allroutbtn]");
    let routeswindow=document.getElementById('RoutesWindow');
    let exitrotesbtn=document.getElementById('exitroutwindowbtn');
    let addroad=document.getElementById('addroadbtn');

    let conterl=0;
    let conterd=0;
    arrowlp.onclick=(event)=>{
        conterl+=1;
        event.stopPropagation();
        if(conterl%2===0){
            arrowlp.classList.remove('rotatearrowback');
            arrowlp.classList.add('rotatearrowclass');
            innerleftpanel.classList.remove('openpanell');
            innerleftpanel.classList.add('hidepanell');

        }
        else {
            arrowlp.classList.remove('rotatearrowclass');
            arrowlp.classList.add('rotatearrowback');
            innerleftpanel.classList.remove('hidepanell');
            innerleftpanel.classList.add('openpanell');
        }
    };
    arrowdp.onclick=(event)=>{
        conterd+=1;
        event.stopPropagation();
        if(conterd%2===0){
            arrowdp.classList.remove('rotatearrowback');
            arrowdp.classList.add('rotatearrowclass');
            mainpanel.classList.remove('openpaneld');
            mainpanel.classList.add('hidepaneld');

        }
        else {
            arrowdp.classList.remove('rotatearrowclass');
            arrowdp.classList.add('rotatearrowback');
            mainpanel.classList.remove('hidepaneld');
            mainpanel.classList.add('openpaneld');
        }
    };
    citiesbtn.onclick=(event)=>{
       if (routeswindow.style.visibility=='hidden'){
           routeswindow.style.visibility='visible';
       }
       else {
           routeswindow.style.visibility='hidden';
       }
    }
    exitrotesbtn.onclick=(event)=>routeswindow.style.visibility='hidden';
    ////////////////////////////////////////////////////////////
    let innercornersroadmap=new Map;
    let addroadactive=false;
    let road;
    addroad.onclick=async ()=>{
        function rotataroad(e){
            if (e.code==='KeyR')
                road.rotateOnWorldAxis(new THREE.Vector3(0,1,0),Math.PI/18);
            if (e.code==='KeyT')
                road.rotateOnWorldAxis(new THREE.Vector3(0,1,0),-Math.PI/18);
        }
        function putroad(e){
            e.preventDefault();
            addroadactive=false;
            innercornersroadmap.set(road,[
                                          [road.getChildByName('leftcorner1'), road.getChildByName('rightcorner1')],
                                          [road.getChildByName('leftcorner2'), road.getChildByName('rightcorner2')]
                                    ]);

            document.removeEventListener("keydown", rotataroad);

        }

        canvas.addEventListener('mousedown',()=>{
            canvas.addEventListener('mouseup',putroad,{capture:false});
            setTimeout(()=>canvas.removeEventListener('mouseup',putroad,{capture:false}), 500);

        },{capture:false});

        if (addroadactive===false) {
            road = await roaddifinitionclick('./images/fullcorneredroad.glb');
            //scene.add(road);
            addroadactive=true;
            setTimeout(function adrod(){
                let raycaster = new THREE.Raycaster();
                raycaster.setFromCamera( mouse, camera );
                var intersects = raycaster.intersectObject( volcanoobj3d, true);

                if ( intersects.length > 0 ) {
                    let p=intersects[0].point;

                   let nearcorns=[];

                    for(let masinncorns of innercornersroadmap.values()){

                        masinncorns.forEach((mascouplecorns, index)=>{
                            mascouplecorns.forEach((value, index)=>{
                                if (p.distanceTo(value.getWorldPosition())<Math.min(road.width, road.length)){//коэффициент для того чтобы найти ряждом какие чужие углы
                                   nearcorns.push(mascouplecorns);
                            }});
                        });
                    }
                    if(nearcorns.length===1){
                        road.positionbytwocorners(nearcorns[0][0].getWorldPosition(),nearcorns[0][1].getWorldPosition(),p);


                    }
                    else {
                        road.position.set(p.x, p.y, p.z);
                    }




                    document.addEventListener("keydown", rotataroad);



                   // traingonormalization(road);
                }
                if(addroadactive)
                setTimeout(()=>adrod(),100);
            },100);
        }
        else {
            addroadactive=false;
            road.cornersystem.material.dispose();
            road.cornersystem.geometry.dispose();
            scene.remove(road.cornersystem);
            road.children.forEach((value,index)=>{//идти с конца переписать, а то плохо глючит
                road.remove(value);
                value.material.dispose();
                value.geometry.dispose()
            });
            scene.remove(road);
            canvas.removeEventListener('mouseup',putroad,{capture:false});
            document.removeEventListener("keydown", rotataroad);

        }


    };

</script>
<script type="module">//скрипт часов
    import {clock, traingo} from "./GameScript.js";

    let clockelem=document.getElementById('clock');

    let formatter = new Intl.DateTimeFormat("ru", {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour:'numeric',
        minute:'numeric'
    });

    setTimeout(function clockgo() {
        clock.setTime(clock.getTime()+3600*1000);
        clockelem.innerHTML=(formatter.format(clock));
        traingo();
        setTimeout(clockgo, 1000);
    },1000);

</script>
<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {traingo,train3dobj,volcanoobj3d,canvas,scene,camera,renderer,controls,light,MTLlod,loader,cubemaploader,cubetextture,roaddifinitionclick} from"./GameScript.js";
    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        let curbtns={};
        canvas.addEventListener('keydown',(event)=>{
            curbtns[event.code]=true;
            movecamera(event)}
        , false);
        canvas.addEventListener('keyup', (event)=>{
                delete curbtns[event.code];
                movecamera(event)}
            , false);
        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);

            if (curbtns.KeyW && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyW && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;;
            }
            else if(curbtns.KeyS && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyW){
                return;
            }
            else if(curbtns.KeyA && curbtns.KeyD){
                return;
            }
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера
    requestAnimationFrame( render );

    function render(time) {
        time *= 0.0001;
        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );
        requestAnimationFrame( render);
    }
</script>

</body>
</html>