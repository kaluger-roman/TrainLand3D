<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
</head>
<body>
<canvas id="canv">

</canvas>


<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {MTLLoader} from "./js/three.js-master/examples/jsm/loaders/MTLLoader.js";
    import {MtlObjBridge} from "./js/three.js-master/examples/jsm/loaders/obj2/bridge/MtlObjBridge.js";
    import {LineMaterial} from "./js/three.js-master/examples/jsm/lines/LineMaterial.js";
    import {RenderPass} from "./js/three.js-master/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./js/three.js-master/examples/jsm/postprocessing/FilmPass.js";
    import {EffectComposer} from "./js/three.js-master/examples/jsm/postprocessing/EffectComposer.js";
    import {FlyControls} from "./js/three.js-master/examples/jsm/controls/FlyControls.js";
    import {TrackballControls} from "./js/three.js-master/examples/jsm/controls/TrackballControls.js";



    let canvas=document.getElementById('canv');
    const scene=new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, 2, 0.1, 5000000);
    camera.position.set(0,400000,0);

    const renderer=new THREE.WebGLRenderer({
        canvas,
        alpha:true,
        logarithmicDepthBuffer: true,
    });
    renderer.autoClearColor = false;
    renderer.setSize(window.innerWidth, window.innerHeight);

    let controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 8000, 0);

    const light = new THREE.DirectionalLight(0xFFFFFF, 1);
    light.position.set(0, 10000, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);

    const MTLlod=new MTLLoader();
    const loader=new THREE.TextureLoader();
    const cubemaploader = new THREE.CubeTextureLoader();
    const objLoader = new OBJLoader2();

    const cubetextture = cubemaploader.load([
            './images/ely_hills/eezabad_ft.jpg',
            './images/ely_hills/eezabad_bk.jpg',
            './images/ely_hills/eezabad_up.jpg',
            './images/ely_hills/eezabad_dn.jpg',
            './images/ely_hills/eezabad_rt.jpg',
            './images/ely_hills/eezabad_lf.jpg']);
    scene.background = cubetextture;
    //задний план

    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        canvas.addEventListener('keydown', movecamera, false);

        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера

    let train3dobj, volcanoobj3d;
    {
        const objLoader = new OBJLoader2();
        MTLlod.load('./images/volcano/volcano0201.mtl', (mtpresult) => {
            const volcmaterials = MtlObjBridge.addMaterialsFromMtlLoader(mtpresult);
            for (const material of Object.values(volcmaterials)) {
                material.side = THREE.DoubleSide;
            }
            objLoader.addMaterials(volcmaterials);
            objLoader.load('./images/volcano/volcano0201.obj', (root) => {   //traverse перебрать потомков есть
                scene.add(root);
                root.modelBoundingBox = new THREE.Box3().setFromObject(root);
                volcanoobj3d=root;
            });
        })
    }//вулкан

    {
        let material=new THREE.MeshBasicMaterial({ map:  loader.load('./images/montagne.jpg')});
        objLoader.addMaterials(material);
        material.side = THREE.DoubleSide;
        objLoader.load('./images/Sci_fi_Train.obj', (root) => {
            train3dobj=root;
            train3dobj.position.y=80000;
            train3dobj.position.x=-70000;
            train3dobj.scale.set(500,500,500);

            let cornersystem;

            let modBB = new THREE.Box3().setFromObject(train3dobj);
            train3dobj.length=modBB.max.x-modBB.min.x;
            train3dobj.width=modBB.max.z-modBB.min.z;
            train3dobj.height=modBB.max.y-modBB.min.y;//возможно перепутана ширина и длина

            let corner1= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xCCFF99}));
            let corner2= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));            //выбрать 3 угол
            let corner3= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));
            let corner4= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));

            corner1.position.set(modBB.max.x,modBB.min.y,modBB.max.z);
            corner2.position.set(modBB.max.x,modBB.min.y,modBB.min.z);
            corner3.position.set(modBB.min.x,modBB.min.y,modBB.max.z);
            corner4.position.set(modBB.min.x,modBB.min.y,modBB.min.z);

            corner3.position.lerp(corner4.position, 0.5);

            corner1.name='corner1';
            corner2.name='corner2';
            corner3.name='corner3';
            corner4.name='corner4';

            cornersystem=new THREE.Mesh(
                new THREE.BoxGeometry( train3dobj.length, train3dobj.height, train3dobj.width),
                new THREE.MeshPhongMaterial({
                    color: 0xFFFFFF,
                    opacity: 0.5,
                    transparent: true,
                }));

            let p=train3dobj.position;
            cornersystem.position.set(p.x,p.y,p.z);
            train3dobj.cornersystem=cornersystem;
            scene.add(cornersystem);

            cornersystem.attach(corner1);
            cornersystem.attach(corner2); //когда add масштабируется и прикпрепляется а attach прикрепляется просто(аттач координаты из внешнего мира и просто крепит), адд переводит во внутренний мир
            cornersystem.attach(corner3);

            train3dobj.trainplain=new Plane();
            train3dobj.trainplain.setFromCoplanarPoints(cornersystem.getChildByName('corner1').getWorldPosition(),cornersystem.getChildByName('corner2').getWorldPosition(),cornersystem.getChildByName('corner3').getWorldPosition());//или position

            train3dobj.forwarddirrect =  new Vector3(1, 0, 0);
            // в какую сторону направлен нос с учетом поворота поверхности
            train3dobj.lookforward=function(){
                let angle, nvector1, nvector2;
                nvector1=new Vector3();
                nvector2=new Vector3();

                function ncross(obj, trainonj){
                    nvector1.crossVectors(trainonj.forwarddirrect, new Vector3(0,1,0)).normalize();
                    nvector2.crossVectors(obj.getWorldDirection(), new Vector3(0,1,0)).normalize();
                }

                ncross(train3dobj, train3dobj);

                angle=nvector1.angleTo(nvector2);
                train3dobj.rotateOnAxis(new Vector3(0,1,0), angle);

                ncross(train3dobj,train3dobj);

                if (angle< nvector1.angleTo(nvector2)){
                    train3dobj.rotateOnAxis(new Vector3(0,-1,0), 2*angle);
                }

               ncross(cornersystem, train3dobj);

                angle=nvector1.angleTo(nvector2);
                cornersystem.rotateOnWorldAxis(new Vector3(0,1,0), angle);

                ncross(cornersystem, train3dobj);

                if (angle< nvector1.angleTo(nvector2)){
                    cornersystem.rotateOnWorldAxis(new Vector3(0,-1,0), 2*angle);
                }
            };

            {
                let helper2 = new THREE.AxisHelper(50000000);
                let helper3 = new THREE.AxisHelper(50000000);
                let helper4 = new THREE.AxisHelper(50000000);
                cornersystem.add(helper4);
                train3dobj.add(helper2);
                scene.add(train3dobj, helper3);//потом удалить помощников
            }

            train3dobj = new Proxy( train3dobj, {
                get(target, prop, receiver) {
                    let reflect= Reflect.get(target, prop, receiver);
                    if (prop === 'position') {
                        let diff = new Vector3();
                        diff.subVectors(cornersystem.position, reflect);
                        let cp = cornersystem.position;
                        cp.set(reflect.x,reflect.y+10000,reflect.z);
                }
                    return typeof reflect == 'function' ? reflect.bind(target) : reflect; // (*)
                }});

            requestAnimationFrame( render );//добавить после
        });
    }//паровоз

    function traingonormalization(curtrain) {
        train3dobj.lookforward();
        let cors=train3dobj.cornersystem;
        let intersect;
        let flag=false;
        let corners=[cors.getChildByName('corner1'),cors.getChildByName('corner2'),cors.getChildByName('corner3')];
        let raysup=[];
        let raysdown=[];
        let upvector=new Vector3(0,1,0);
        let downvector=new Vector3(0,-1,0);

       raycastt(upvector,raysup);
       raycastt(downvector,raysdown);
       function raycastt(vector, masrays) {
           scene.updateMatrixWorld();
           curtrain.updateMatrixWorld();
           volcanoobj3d.updateMatrixWorld();
           cors.updateMatrixWorld();
           for (let i =1;i<4;i++){
               masrays.push(new THREE.Raycaster(cors.localToWorld((new Vector3()).copy(cors.getChildByName(`corner${i}`).position)), vector.normalize()));//можно фар и нир понизить
           }
           masrays.forEach((ray, index)=>{
               intersect = ray.intersectObject(volcanoobj3d, true);//важно флаг тру чтоб проверять загружаемые объекты
               if ( (intersect.length >0) && (intersect[0].distance>curtrain.height/50))//
               {
                   flag=true;
                   let curpos=new Vector3();
                   curpos.copy(corners[index].position);
                   let curworldposoftrain=new Vector3();
                   curworldposoftrain.copy(cors.position);
                   curworldposoftrain.addScaledVector(cors.getChildByName(`corner${index+1}`).position, cors.scale.y);

                   let futureworldpos=new Vector3(curworldposoftrain.x, intersect[0].point.y+100, curworldposoftrain.z);
                   let futureposlocal=cors.worldToLocal(futureworldpos);
                   if (cors.getWorldDirection().angleTo(new Vector3(1,0,0))<=Math.PI/2){
                       futureposlocal.applyAxisAngle(upvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                   }
                   else {
                       futureposlocal.applyAxisAngle(downvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                   }
                   cors.getChildByName(`corner${index+1}`).position.set(futureposlocal.x, futureposlocal.y, futureposlocal.z);//убрать прибавление позиции системы многократное каждый раз

               }
           });
       }

        /////////////////////////


        if (flag) {
            corners.sort((a, b) => {
                let ap=(a.position);
                let bp=(b.position);            //localtoworld????
                if (ap.y > bp.y) return 1;
                if (ap.y < bp.y) return -1;
                if (ap.y = bp.y) return 0;
            });

            curtrain.oldaxis=new Vector3();
            curtrain.oldaxis.copy(curtrain.trainplain.normal);
            curtrain.trainplain.setFromCoplanarPoints(corners[0].getWorldPosition().divideScalar(cors.scale.y), corners[1].getWorldPosition().divideScalar(cors.scale.y),corners[2].getWorldPosition().divideScalar(cors.scale.y));
            if(curtrain.trainplain.normal.angleTo(upvector)>=Math.PI/2){
                curtrain.trainplain.normal.negate();
            }

            let quaternion2=new THREE.Quaternion();
            quaternion2.setFromUnitVectors(curtrain.oldaxis.normalize(),curtrain.trainplain.normal.normalize());
            curtrain.applyQuaternion(quaternion2);
            curtrain.position.y=corners[2].getWorldPosition().y;
        }

    }//выравнивание паровоза или чего то по вертикали чтобы не проваливалось

    function render(time) {
        time *= 0.0001;

        train3dobj.position.x=190000*Math.cos(time);
        train3dobj.position.z=190000*Math.sin(time);
        train3dobj.forwarddirrect=new Vector3(190000*Math.cos(time+1.5),0,190000*Math.sin(time+1.5))

     /*   train3dobj.position.x+=100;
        train3dobj.forwarddirrect=new Vector3(1,0,0);*/

      train3dobj.updateMatrix();
      train3dobj.updateMatrixWorld();

     if (volcanoobj3d!==undefined)
        traingonormalization(train3dobj);

        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );

        requestAnimationFrame( render);
    }
</script>
<script>
    const mainscript=document.getElementById('mainscenescript');
    async function loadfunc(){
         
    }
    mainscript.onload=loadfunc();
</script>
</body>
</html>