<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
    <link rel="stylesheet" href="routescss.css">
</head>
<body>

<div id="mainflex">
    <canvas id="canv" >

    </canvas>
    <div id="mainpanelgrid">
        <div id="mainpanel"><img id='arrowdp' src="images/arrowdown.png">панель</div>
    </div>
    <div id="leftpanel">
        <div id="innerleftpanel">
            <img id='arrowlp' src="images/arrowleft.png">
            <img class="iconleftpanel" data-allcities="true" src="images/home.png">
            <span class="iconheadersleftpanel">Города Влияния</span>
            <img class="iconleftpanel" data-allroutbtn="true" src="images/mapicon.png">
            <span class="iconheadersleftpanel">Маршруты</span>
        </div>
    </div>
    <div id="avatar">картинка персонажа</div>
    <div id="MAP">картинка персонажа</div>
    <div id="toppanel">картинка персонажа</div>
    <div id="clock"></div>
    <div id="RoutesWindow">
        <h1 id="routwndheader">Мои Маршруты</h1>
        <img src="images/krestikdlyokon.png" id="exitroutwindowbtn">
        <span class="str1"> </span>
    </div>
</div>
<script>
    let arrowlp=document.getElementById('arrowlp');
    let innerleftpanel=document.getElementById('innerleftpanel');
    let arrowdp=document.getElementById('arrowdp');
    let mainpanel=document.getElementById('mainpanel');
    let mainflex=document.getElementById('mainflex');
    let citiesbtn=document.querySelector("[data-allroutbtn]");
    let routeswindow=document.getElementById('RoutesWindow');
    let exitrotesbtn=document.getElementById('exitroutwindowbtn');
    let conterl=0;
    let conterd=0;
    arrowlp.onclick=(event)=>{
        conterl+=1;
        event.stopPropagation();
        if(conterl%2===0){
            arrowlp.classList.remove('rotatearrowback');
            arrowlp.classList.add('rotatearrowclass');
            innerleftpanel.classList.remove('openpanell');
            innerleftpanel.classList.add('hidepanell');

        }
        else {
            arrowlp.classList.remove('rotatearrowclass');
            arrowlp.classList.add('rotatearrowback');
            innerleftpanel.classList.remove('hidepanell');
            innerleftpanel.classList.add('openpanell');
        }
    };
    arrowdp.onclick=(event)=>{
        conterd+=1;
        event.stopPropagation();
        if(conterd%2===0){
            arrowdp.classList.remove('rotatearrowback');
            arrowdp.classList.add('rotatearrowclass');
            mainpanel.classList.remove('openpaneld');
            mainpanel.classList.add('hidepaneld');

        }
        else {
            arrowdp.classList.remove('rotatearrowclass');
            arrowdp.classList.add('rotatearrowback');
            mainpanel.classList.remove('hidepaneld');
            mainpanel.classList.add('openpaneld');
        }
    };
    citiesbtn.onclick=(event)=>{
       if (routeswindow.style.visibility=='hidden'){
           routeswindow.style.visibility='visible';
       }
       else {
           routeswindow.style.visibility='hidden';
       }
    }
    exitrotesbtn.onclick=(event)=>routeswindow.style.visibility='hidden';

</script>
<script>//скрипт часов
    let clockelem=document.getElementById('clock');
    let servertimestamp=0;//получить с сервера
    let formatter = new Intl.DateTimeFormat("ru", {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour:'numeric',
        minute:'numeric'
    });
    let clock=new Date(servertimestamp);
    setTimeout(function clockgo() {
        clock.setTime(clock.getTime()+3600*1000);
        clockelem.innerHTML=(formatter.format(clock));
        setTimeout(clockgo, 1000);
    },1000);

</script>
<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {train3dobj,volcanoobj3d,canvas,scene,camera,renderer,controls,light,MTLlod,loader,cubemaploader,objLoader,cubetextture} from"./GameScript.js";
    import {MTLLoader} from "./js/three.js-master/examples/jsm/loaders/MTLLoader.js";
    import {MtlObjBridge} from "./js/three.js-master/examples/jsm/loaders/obj2/bridge/MtlObjBridge.js";
    import {LineMaterial} from "./js/three.js-master/examples/jsm/lines/LineMaterial.js";
    import {RenderPass} from "./js/three.js-master/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./js/three.js-master/examples/jsm/postprocessing/FilmPass.js";
    import {EffectComposer} from "./js/three.js-master/examples/jsm/postprocessing/EffectComposer.js";
    import {FlyControls} from "./js/three.js-master/examples/jsm/controls/FlyControls.js";
    import {TrackballControls} from "./js/three.js-master/examples/jsm/controls/TrackballControls.js";

    function promisify(f) {
        return function (...args) { // возвращает функцию-обёртку
            return new Promise((resolve, reject) => {
                function callback(err, result) { // наш специальный колбэк для f
                    if (err) {
                        return reject(err);
                    } else {
                        resolve(result);
                    }
                }
                args.push(callback); // добавляем колбэк в конец аргументов f
                f.call(this, ...args); // вызываем оригинальную функцию
            });
        };
    };



    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        let curbtns={};
        canvas.addEventListener('keydown',(event)=>{
            curbtns[event.code]=true;
            movecamera(event)}
        , false);
        canvas.addEventListener('keyup', (event)=>{
                delete curbtns[event.code];
                movecamera(event)}
            , false);
        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);

            if (curbtns.KeyW && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyW && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;;
            }
            else if(curbtns.KeyS && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyW){
                return;
            }
            else if(curbtns.KeyA && curbtns.KeyD){
                return;
            }
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера




    function traingonormalization(curtrain) {
        train3dobj.lookforward();
        let cors=train3dobj.cornersystem;
        let intersect;
        let flag=false;
        let corners=[cors.getChildByName('corner1'),cors.getChildByName('corner2'),cors.getChildByName('corner3')];
        let raysup=[];
        let raysdown=[];
        let upvector=new Vector3(0,1,0);
        let downvector=new Vector3(0,-1,0);

       raycastt(upvector,raysup);
       raycastt(downvector,raysdown);
       function raycastt(vector, masrays) {
           scene.updateMatrixWorld();
           curtrain.updateMatrixWorld();
           volcanoobj3d.updateMatrixWorld();
           cors.updateMatrixWorld();
           for (let i =1;i<4;i++){
               masrays.push(new THREE.Raycaster(cors.localToWorld((new Vector3()).copy(cors.getChildByName(`corner${i}`).position)), vector.normalize()));//можно фар и нир понизить
           }
           masrays.forEach((ray, index)=>{
               intersect = ray.intersectObject(volcanoobj3d, true);//важно флаг тру чтоб проверять загружаемые объекты
               if ( (intersect.length >0) && (intersect[0].distance>curtrain.height/50))//
               {
                   flag=true;
                   let curpos=new Vector3();
                   curpos.copy(corners[index].position);
                   let curworldposoftrain=new Vector3();
                   curworldposoftrain.copy(cors.position);
                   curworldposoftrain.addScaledVector(cors.getChildByName(`corner${index+1}`).position, cors.scale.y);

                   let futureworldpos=new Vector3(curworldposoftrain.x, intersect[0].point.y+100, curworldposoftrain.z);
                   let futureposlocal=cors.worldToLocal(futureworldpos);
                   if (cors.getWorldDirection().angleTo(new Vector3(1,0,0))<=Math.PI/2){
                       futureposlocal.applyAxisAngle(upvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                   }
                   else {
                       futureposlocal.applyAxisAngle(downvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                   }
                   cors.getChildByName(`corner${index+1}`).position.set(futureposlocal.x, futureposlocal.y, futureposlocal.z);//убрать прибавление позиции системы многократное каждый раз

               }
           });
       }

        /////////////////////////


        if (flag) {
            corners.sort((a, b) => {
                let ap=(a.position);
                let bp=(b.position);            //localtoworld????
                if (ap.y > bp.y) return 1;
                if (ap.y < bp.y) return -1;
                if (ap.y = bp.y) return 0;
            });

            curtrain.oldaxis=new Vector3();
            curtrain.oldaxis.copy(curtrain.trainplain.normal);
            curtrain.trainplain.setFromCoplanarPoints(corners[0].getWorldPosition().divideScalar(cors.scale.y), corners[1].getWorldPosition().divideScalar(cors.scale.y),corners[2].getWorldPosition().divideScalar(cors.scale.y));
            if(curtrain.trainplain.normal.angleTo(upvector)>=Math.PI/2){
                curtrain.trainplain.normal.negate();
            }

            let quaternion2=new THREE.Quaternion();
            quaternion2.setFromUnitVectors(curtrain.oldaxis.normalize(),curtrain.trainplain.normal.normalize());
            curtrain.applyQuaternion(quaternion2);
            curtrain.position.y=corners[2].getWorldPosition().y;

        }

    }//выравнивание паровоза или чего то по вертикали чтобы не проваливалось
    setTimeout(()=>requestAnimationFrame( render ),3000);//добавить после
    function render(time) {
        time *= 0.0001;

        train3dobj.position.x=190000*Math.cos(time);
        train3dobj.position.z=190000*Math.sin(time);
        train3dobj.forwarddirrect=new Vector3(190000*Math.cos(time+1.5),0,190000*Math.sin(time+1.5))

     /*   train3dobj.position.x+=100;
        train3dobj.forwarddirrect=new Vector3(1,0,0);*/

      train3dobj.updateMatrix();
      train3dobj.updateMatrixWorld();

        traingonormalization(train3dobj);

        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );

        requestAnimationFrame( render);
    }
</script>
<script>
    const mainscript=document.getElementById('mainscenescript');
    async function loadfunc(){
         
    }
    mainscript.onload=loadfunc();
</script>
</body>
</html>