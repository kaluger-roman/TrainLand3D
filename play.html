<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
</head>
<body>
<canvas id="canv">

</canvas>


<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {MTLLoader} from "./js/three.js-master/examples/jsm/loaders/MTLLoader.js";
    import {MtlObjBridge} from "./js/three.js-master/examples/jsm/loaders/obj2/bridge/MtlObjBridge.js";
    import {LineMaterial} from "./js/three.js-master/examples/jsm/lines/LineMaterial.js";
    import {RenderPass} from "./js/three.js-master/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./js/three.js-master/examples/jsm/postprocessing/FilmPass.js";
    import {EffectComposer} from "./js/three.js-master/examples/jsm/postprocessing/EffectComposer.js";
    import {FlyControls} from "./js/three.js-master/examples/jsm/controls/FlyControls.js";
    import {TrackballControls} from "./js/three.js-master/examples/jsm/controls/TrackballControls.js";


    let canvas=document.getElementById('canv');
    const scene=new THREE.Scene();
    const fov = 75;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 5000000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    //camera.lookAt(new Vector3(0,0,0));
    camera.position.set(0,400000,0);
    const renderer=new THREE.WebGLRenderer({
        canvas,
        alpha:true,
        logarithmicDepthBuffer: true,
    });
    renderer.autoClearColor = false;
    const MTLlod=new MTLLoader();
    const loader=new THREE.TextureLoader();
    {
        const cubemaploader = new THREE.CubeTextureLoader();
        const cubetextture = cubemaploader.load([
            './images/ely_hills/eezabad_ft.jpg',
            './images/ely_hills/eezabad_bk.jpg',
            './images/ely_hills/eezabad_up.jpg',
            './images/ely_hills/eezabad_dn.jpg',
            './images/ely_hills/eezabad_rt.jpg',
            './images/ely_hills/eezabad_lf.jpg']);
        scene.background = cubetextture;
    }
    let controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 8000, 0);
    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        canvas.addEventListener('keydown', movecamera, false);

        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера
    renderer.setSize(window.innerWidth, window.innerHeight);

    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 10000, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);

    let material=new THREE.MeshBasicMaterial({ map:  loader.load('./images/montagne.jpg')});
    const objLoader = new OBJLoader2();
    let train3dobj, volcanoobj3d;
    {
        const objLoader = new OBJLoader2();
        MTLlod.load('./images/volcano/volcano0201.mtl', (mtpresult) => {
            const volcmaterials = MtlObjBridge.addMaterialsFromMtlLoader(mtpresult);
            for (const material of Object.values(volcmaterials)) {
                material.side = THREE.FrontSide;
            }
            objLoader.addMaterials(volcmaterials);
            objLoader.load('./images/volcano/volcano0201.obj', (root) => {
                /* root.traverse(function (node) {
                 if (node.isMesh) node.material = material;
             });*/
                scene.add(root);
                root.modelBoundingBox = new THREE.Box3().setFromObject(root);

                volcanoobj3d=root;
            });
        })
    }//вулкан
    let trainsystem;
    {
        objLoader.addMaterials(material);
        material.side = THREE.DoubleSide;
        objLoader.load('./images/ldm12.obj', (root) => {
            /*root.traverse(function (node) {
                if (node.isMesh) node.material = material;
            });*/

            train3dobj=root;
            train3dobj.position.y=80000;
            train3dobj.position.x=80000;
            train3dobj.rotateOnAxis(new Vector3(0,1,0),Math.PI/2)
            train3dobj.scale.set(55,55,55);
            let modBB = new THREE.Box3().setFromObject(train3dobj);
            train3dobj.length=modBB.max.x-modBB.min.x;
            train3dobj.width=modBB.max.z-modBB.min.z;
            train3dobj.height=modBB.max.y-modBB.min.y;//возможно перепутана ширина и длина
            let corner1=new Vector3(modBB.max.x,modBB.min.y,modBB.max.z);
            let corner2=new Vector3(modBB.max.x,modBB.min.y,modBB.min.z);
            let corner3=new Vector3(modBB.min.x,modBB.min.y,modBB.max.z);
            let corner4=new Vector3(modBB.min.x,modBB.min.y,modBB.min.z);
            let corners=[];
            corners.push(corner1,corner2,corner3,corner4);
            train3dobj.corners=corners;
            train3dobj.trainplain=new Plane();
            train3dobj.trainplain.setFromCoplanarPoints(train3dobj.corners[0],train3dobj.corners[1],train3dobj.corners[2]);
           trainsystem=new THREE.Object3D;
           trainsystem.add(train3dobj);
           let objcorners=corners.map((value) =>{
                   let ob=new THREE.Object3D();
                   ob.position.set(value.x,value.y,value.z);
                   return ob;
               } );
           trainsystem.add(...objcorners);
            scene.add(trainsystem);

            requestAnimationFrame( render );//добавить после
        });
    }//паровоз

    function traingonormalization(curtrainsystem) {
        let curtrain=curtrainsystem.children[0];
        let upvector=new Vector3(0,-1,0);
        let p=curtrain.position;
        try {
            curtrain.rotateOnWorldAxis(trainsystem.oldaxis, Math.PI*2+trainsystem.oldangle);
        }
        catch (e) {
            console.log('erraaa');
        }
        let rays=[];
            for (let i =0;i<4;i++){
                rays.push(new THREE.Raycaster((curtrainsystem.children[i+1].position), upvector.normalize()));//можно фар и нир понизить
            }
        let intersect;
        let flag=false;
        let corners=[curtrainsystem.children[1],curtrainsystem.children[2],curtrainsystem.children[3],curtrainsystem.children[4]];
        curtrainsystem.oldcorners=corners;
        rays.forEach((ray, index,array)=>{
            intersect = ray.intersectObject(volcanoobj3d, true);//важно флаг тру чтоб проверять загружаемые объекты
            if ( (intersect.length >0) && (intersect[0].distance>0))//
            {
                flag=true;
                let newcorn=new THREE.Object3D();
                newcorn.position.set(corners[index].position.x+curtrainsystem.position.x, p.y-intersect[0].distance,corners[index].position.z+curtrainsystem.position.z);//убрать прибавление позиции системы многократное каждый раз
                corners.splice(index,1, newcorn);
                curtrainsystem.children[index+1]=newcorn;
               // obj.position.y =  obj.position.y-intersect[0].distance+modelBoundingBox.max.y-modelBoundingBox.min.y;
            }
        });
        if (flag) {
            corners.sort((a, b) => {
                if (a.position.y > b.position.y) return 1;
                if (a.position.y < b.position.y) return -1;
                if (a.position.y = b.position.y) return 0;
            });
            let _vector1 = new Vector3();
            let _vector2 = new Vector3();
            let futurenormal = (_vector1.subVectors(corners[0].position, corners[3].position).cross(_vector2.subVectors(corners[1].position, corners[3].position)).normalize());//ТУТ ТОЛЬКО НОРМАЛЬ КОНСТ ДО НУЛЯ НЕВЕРНОЕ!!!ИСПОЛЬЗ ФУНКЦИИ
            let copynormal=new Vector3();
            copynormal.copy(futurenormal);
            let copynormal1=new Vector3();
            copynormal1.copy(futurenormal);
            trainsystem.oldaxis=futurenormal.cross(curtrain.trainplain.normal).negate();
                trainsystem.oldangle=copynormal1.angleTo(curtrain.trainplain.normal);
            curtrain.rotateOnWorldAxis( trainsystem.oldaxis,   trainsystem.oldangle);
            curtrain.position.y = corners[0].position.y + curtrain.height*2;
            curtrain.trainplain = new Plane(copynormal, 0);
            trainsystem.children.forEach((c,i)=>{
                if(i>0){
                    c=trainsystem.oldcorners[i-1];
                }
            });

        }
    }//выравнивание паровоза или чего то по вертикали чтобы не проваливалось

    function render(time) {
        time *= 0.1;
     // trainsystem.position.x+=1;
        traingonormalization(trainsystem);


        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );
        requestAnimationFrame( render);
    }
</script>
<script>
    const mainscript=document.getElementById('mainscenescript');
    async function loadfunc(){
         
    }
    mainscript.onload=loadfunc();
</script>
</body>
</html>