<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
</head>
<body>
<canvas id="canv">

</canvas>


<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {MTLLoader} from "./js/three.js-master/examples/jsm/loaders/MTLLoader.js";
    import {MtlObjBridge} from "./js/three.js-master/examples/jsm/loaders/obj2/bridge/MtlObjBridge.js";
    import {LineMaterial} from "./js/three.js-master/examples/jsm/lines/LineMaterial.js";
    import {RenderPass} from "./js/three.js-master/examples/jsm/postprocessing/RenderPass.js";
    import {FilmPass} from "./js/three.js-master/examples/jsm/postprocessing/FilmPass.js";
    import {EffectComposer} from "./js/three.js-master/examples/jsm/postprocessing/EffectComposer.js";
    import {FlyControls} from "./js/three.js-master/examples/jsm/controls/FlyControls.js";
    import {TrackballControls} from "./js/three.js-master/examples/jsm/controls/TrackballControls.js";


    let canvas=document.getElementById('canv');
    const scene=new THREE.Scene();
    const fov = 75;
    const aspect = 2;  // the canvas default
    const near = 0.1;
    const far = 5000000;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    //camera.lookAt(new Vector3(0,0,0));
    camera.position.set(0,400000,0);
    const renderer=new THREE.WebGLRenderer({
        canvas,
        alpha:true,
        logarithmicDepthBuffer: true,
    });
    renderer.autoClearColor = false;
    const MTLlod=new MTLLoader();
    const loader=new THREE.TextureLoader();
    {
        const cubemaploader = new THREE.CubeTextureLoader();
        const cubetextture = cubemaploader.load([
            './images/ely_hills/eezabad_ft.jpg',
            './images/ely_hills/eezabad_bk.jpg',
            './images/ely_hills/eezabad_up.jpg',
            './images/ely_hills/eezabad_dn.jpg',
            './images/ely_hills/eezabad_rt.jpg',
            './images/ely_hills/eezabad_lf.jpg']);
        scene.background = cubetextture;
    }
    let controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 8000, 0);
    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        canvas.addEventListener('keydown', movecamera, false);

        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера
    renderer.setSize(window.innerWidth, window.innerHeight);

    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(0, 10000, 0);
    light.target.position.set(-5, 0, 0);
    scene.add(light);
    scene.add(light.target);

    let material=new THREE.MeshBasicMaterial({ map:  loader.load('./images/montagne.jpg')});
    const objLoader = new OBJLoader2();
    let train3dobj, volcanoobj3d;
    {
        const objLoader = new OBJLoader2();
        MTLlod.load('./images/volcano/volcano0201.mtl', (mtpresult) => {
            const volcmaterials = MtlObjBridge.addMaterialsFromMtlLoader(mtpresult);
            for (const material of Object.values(volcmaterials)) {
                material.side = THREE.DoubleSide;
            }
            objLoader.addMaterials(volcmaterials);
            objLoader.load('./images/volcano/volcano0201.obj', (root) => {
                /* root.traverse(function (node) {
                 if (node.isMesh) node.material = material;
             });*/
                scene.add(root);
                root.modelBoundingBox = new THREE.Box3().setFromObject(root);

                volcanoobj3d=root;
            });
        })
    }//вулкан
    let cornersystem;
    {
        objLoader.addMaterials(material);
        material.side = THREE.DoubleSide;
        objLoader.load('./images/ldm12.obj', (root) => {
            train3dobj=root;
            train3dobj.position.y=80000;
            train3dobj.position.x=-70000;
            train3dobj.scale.set(50,50,50);




            let modBB = new THREE.Box3().setFromObject(train3dobj);
            train3dobj.length=modBB.max.x-modBB.min.x;
            train3dobj.width=modBB.max.z-modBB.min.z;
            train3dobj.height=modBB.max.y-modBB.min.y;//возможно перепутана ширина и длина


            let corner1= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xCCFF99}));
            let corner2= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));            //выбрать 3 угол
            let corner3= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));
            let corner4= new THREE.Mesh(new THREE.SphereBufferGeometry(1000, 6, 6),new THREE.MeshPhongMaterial({emissive: 0xFFFF00}));

            corner1.position.set(modBB.max.x,modBB.min.y,modBB.max.z);
            corner2.position.set(modBB.max.x,modBB.min.y,modBB.min.z);
            corner3.position.set(modBB.min.x,modBB.min.y,modBB.max.z);
            corner4.position.set(modBB.min.x,modBB.min.y,modBB.min.z);

            corner3.position.lerp(corner4.position, 0.5);

                corner1.offsettrain=new Vector3();
                corner2.offsettrain=new Vector3();
                corner3.offsettrain=new Vector3();
                corner4.offsettrain=new Vector3();

                corner1.offsettrain.subVectors(corner1.position, train3dobj.position);
                corner2.offsettrain.subVectors(corner2.position, train3dobj.position);
                corner3.offsettrain.subVectors(corner3.position, train3dobj.position);
                corner4.offsettrain.subVectors(corner4.position, train3dobj.position);

            corner1.name='corner1';
            corner2.name='corner2';
            corner3.name='corner3';
            corner4.name='corner4';

            cornersystem=new THREE.Mesh(
                new THREE.BoxGeometry( train3dobj.length, train3dobj.height, train3dobj.width),
                new THREE.MeshPhongMaterial({
                    color: 0xFFFFFF,
                    opacity: 0.5,
                    transparent: true,
                }));
            let p=train3dobj.position;
            cornersystem.position.set(p.x+train3dobj.width/15,p.y,p.z-train3dobj.length*2.5);
            train3dobj.cornersystem=cornersystem;
            scene.add(cornersystem);

            cornersystem.attach(corner1);
            cornersystem.attach(corner2); //когда add масштабируется и прикпрепляется а attach прикрепляется просто(аттач координаты из внешнего мира и просто крепит), адд переводит во внутренний мир
            cornersystem.attach(corner3);

            train3dobj.trainplain=new Plane();
            train3dobj.trainplain.setFromCoplanarPoints(cornersystem.getChildByName('corner1').getWorldPosition(),cornersystem.getChildByName('corner2').getWorldPosition(),cornersystem.getChildByName('corner3').getWorldPosition());//или position

          /*  train3dobj.rotateOnAxis(train3dobj.trainplain.normal,Math.PI/3); //вокруг этой оси надо разворачивать при преобразовании координат к локакльным в нормализейшн
            train3dobj.rotateOnAxis(new Vector3(0,0,1),Math.PI/12);
            train3dobj.trainplain.normal.applyAxisAngle(new Vector3(0,0,1),Math.PI/12);*/

          /* train3dobj.rotateOnAxis((new Vector3(0,0,1)), -train3dobj.trainplain.normal.angleTo(new Vector3(0,1,0)) );
           train3dobj.rotateOnAxis(new Vector3(0,1,0),- train3dobj.getWorldDirection().angleTo(new Vector3(0,0,1)) );*/

            let helper=new THREE.BoxHelper(train3dobj,  0xFFFF00);
            let helper2=new THREE.AxisHelper(50000000);
            let helper3=new THREE.AxisHelper(50000000);
            let helper4=new THREE.AxisHelper(50000000);
           let arrowHelper = new THREE.ArrowHelper( train3dobj.trainplain.normal, train3dobj.position, 50000, 0x666666);
            cornersystem.add(helper4);
            train3dobj.add(helper2);

            scene.add(train3dobj, helper3,arrowHelper);

           setInterval(()=>traingonormalization(train3dobj),30);

         /*  train3dobj.children.forEach((child)=>{
               let p=child.position;
               let s=train3dobj.scale;
               p.set(p.x+train3dobj.width/s.x,p.y+train3dobj.height/s.y,p.z+train3dobj.length/s.z)});*/
            /*train3dobj = new Proxy( train3dobj, {
                get(target, prop, receiver) { // receiver
                    let reflect= Reflect.get(target, prop, receiver);
                    if (prop == 'position') {
                        let diff = new Vector3();

                        diff.subVectors(cornersystem.position, reflect);
                        let cp = cornersystem.position;
                        cp.set(reflect.x+target.width/15,reflect.y+10000,reflect.z-target.length*2.5);
                }
                    return typeof reflect == 'function' ? reflect.bind(target) : reflect; // (*)
                }});*/

            requestAnimationFrame( render );//добавить после
        });
    }//паровоз

    function traingonormalization(curtrain) {
        let cors=train3dobj.cornersystem;
        let intersect;
        let flag=false;
        let corners=[cors.getChildByName('corner1'),cors.getChildByName('corner2'),cors.getChildByName('corner3')];
        scene.updateMatrixWorld();
        curtrain.updateMatrixWorld();
        volcanoobj3d.updateMatrixWorld();
        cors.updateMatrixWorld();

        let raysup=[];
        let upvector=new Vector3(0,1,0);
        let downvector=new Vector3(0,-1,0);
        for (let i =1;i<4;i++){
            raysup.push(new THREE.Raycaster(cors.localToWorld((new Vector3()).copy(cors.getChildByName(`corner${i}`).position)), upvector.normalize()));//можно фар и нир понизить
        }
        raysup.forEach((ray, index)=>{
            intersect = ray.intersectObject(volcanoobj3d, true);//важно флаг тру чтоб проверять загружаемые объекты
            if ( (intersect.length >0) && (intersect[0].distance>150))//
            {
                flag=true;
                let curpos=new Vector3();
                curpos.copy(corners[index].position);
                let curworldposoftrain=new Vector3();
                curworldposoftrain.copy(cors.position);
                curworldposoftrain.addScaledVector(cors.getChildByName(`corner${index+1}`).position, cors.scale.y);

                let futureworldpos=new Vector3(curworldposoftrain.x, intersect[0].point.y+100, curworldposoftrain.z);
                let futureposlocal=cors.worldToLocal(futureworldpos);
                //futureposlocal.applyAxisAngle((new Vector3(0,0,1)), curtrain.trainplain.normal.angleTo(new Vector3(0,1,0)) );
                if (cors.getWorldDirection().angleTo(new Vector3(1,0,0))<=Math.PI/2){
                    futureposlocal.applyAxisAngle(upvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                }
                else {
                    futureposlocal.applyAxisAngle(downvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                }
                cors.getChildByName(`corner${index+1}`).position.set(futureposlocal.x, futureposlocal.y, futureposlocal.z);//убрать прибавление позиции системы многократное каждый раз

            }
        });

        scene.updateMatrixWorld();
        curtrain.updateMatrixWorld();
        volcanoobj3d.updateMatrixWorld();
        cors.updateMatrixWorld();


        let rays=[];
        for (let i =1;i<4;i++){
            rays.push(new THREE.Raycaster(cors.localToWorld((new Vector3()).copy(cors.getChildByName(`corner${i}`).position)), downvector.normalize()));//можно фар и нир понизить
        }



        rays.forEach((ray, index)=>{
            intersect = ray.intersectObject(volcanoobj3d, true);//важно флаг тру чтоб проверять загружаемые объекты
            if ( (intersect.length >0) && (intersect[0].distance>150))//
            {
                flag=true;
                let curpos=new Vector3();
                curpos.copy(corners[index].position);
                let curworldposoftrain=new Vector3();
                curworldposoftrain.copy(cors.position);
                curworldposoftrain.addScaledVector(cors.getChildByName(`corner${index+1}`).position, cors.scale.y);

                let futureworldpos=new Vector3(curworldposoftrain.x, intersect[0].point.y+100, curworldposoftrain.z);
                let futureposlocal=cors.worldToLocal(futureworldpos);
                //futureposlocal.applyAxisAngle((new Vector3(0,0,1)), curtrain.trainplain.normal.angleTo(new Vector3(0,1,0)) );
                if (cors.getWorldDirection().angleTo(new Vector3(1,0,0))<=Math.PI/2){
                    futureposlocal.applyAxisAngle(upvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                }
                else {
                    futureposlocal.applyAxisAngle(downvector, cors.getWorldDirection().angleTo(new Vector3(0,0,1)) );
                }

                cors.getChildByName(`corner${index+1}`).position.set(futureposlocal.x, futureposlocal.y, futureposlocal.z);//необъяснимый костыль, оси х и з

            }
        });


        /////////////////////////



        if (flag) {
            corners.sort((a, b) => {
                let ap=(a.position);
                let bp=(b.position);            //localtoworld????
                if (ap.y > bp.y) return 1;
                if (ap.y < bp.y) return -1;
                if (ap.y = bp.y) return 0;
            });
            let _vector1 = new Vector3();
            let _vector2 = new Vector3();
            //let futurenormal = (_vector1.subVectors(corners[0].getWorldPosition().divideScalar(curtrain.scale.y), corners[2].getWorldPosition().divideScalar(curtrain.scale.y)).cross(_vector2.subVectors(corners[1].getWorldPosition().divideScalar(curtrain.scale.y), corners[2].getWorldPosition().divideScalar(curtrain.scale.y))).normalize());//ТУТ ТОЛЬКО НОРМАЛЬ КОНСТ ДО НУЛЯ НЕВЕРНОЕ!!!ИСПОЛЬЗ ФУНКЦИИ
            curtrain.oldaxis=new Vector3();
            curtrain.oldaxis.copy(curtrain.trainplain.normal);
            curtrain.trainplain.setFromCoplanarPoints(corners[0].getWorldPosition().divideScalar(cors.scale.y), corners[1].getWorldPosition().divideScalar(cors.scale.y),corners[2].getWorldPosition().divideScalar(cors.scale.y));
            if(curtrain.trainplain.normal.angleTo(upvector)>=Math.PI/2){
                curtrain.trainplain.normal.negate();
            }
       /*    let helper= new THREE.PlaneHelper(curtrain.trainplain, 5000000);
            scene.add(helper);*/

           /* let copynormal=new Vector3();
            copynormal.copy(futurenormal);
            let copynormal1=new Vector3();
            copynormal1.copy(futurenormal);
            curtrain.oldaxis=futurenormal.cross(curtrain.trainplain.normal).negate();*/
            //curtrain.oldangle=copynormal1.angleTo(curtrain.trainplain.normal);
            /*let oldposcorn=[];
            corners.forEach((value => {let nv=new Vector3();
            oldposcorn.push(nv.copy(value.getWorldPosition()))}));*/

            let quaternion2=new THREE.Quaternion();
            quaternion2.setFromUnitVectors(curtrain.oldaxis.normalize(),curtrain.trainplain.normal.normalize());
            curtrain.applyQuaternion(quaternion2);
           // curtrain.applyQuaternion(quaternion1);

            //curtrain.rotateOnAxis( curtrain.oldaxis.cross((curtrain.trainplain.normal)  ),   curtrain.oldaxis.angleTo(curtrain.trainplain.normal));

        /*    corners.forEach(((value, index) => {
                value.position.setComponent(1, oldposcorn[index].y+300);
            }));*/
           // curtrain.position.y = corners[0].position.y + curtrain.height;


           // corners.forEach((value => value.position.y+=curtrain.height));

           // curtrain.trainplain = new Plane(copynormal, 0);
            /*trainsystem.children.forEach((c,i)=>{
                if(i>0){
                    c=trainsystem.oldcorners[i-1];
                }
            });*/

        }

    }//выравнивание паровоза или чего то по вертикали чтобы не проваливалось

    function render(time) {
        time *= 0.0001;
        train3dobj.position.x+=100;
        //train3dobj.cornersystem.rotation.y=1.57;
        //train3dobj.rotation.y=1.57;
      train3dobj.updateMatrix();
      train3dobj.updateMatrixWorld();
      //train3dobj.children[35].updateWorldMatrix();
      //console.log(train3dobj.children[35].getWorldPosition());
     // train3dobj.dispatchEvent(postrainevent);
     //traingonormalization(train3dobj);


        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );
        requestAnimationFrame( render);
    }
</script>
<script>
    const mainscript=document.getElementById('mainscenescript');
    async function loadfunc(){
         
    }
    mainscript.onload=loadfunc();
</script>
</body>
</html>