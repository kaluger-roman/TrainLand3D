<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Play KufaTrains</title>
    <link rel="stylesheet" href="PLAYCSS.css">
    <link rel="stylesheet" href="routescss.css">
</head>
<body>

<div id="mainflex">
    <canvas id="canv" >

    </canvas>
    <div id="mainpanelgrid">
        <div id="mainpanel">
            <img id='arrowdp' src="images/arrowdown.png">        <img id="addroadbtn" src="images/roadicon.png">
        </div>

    </div>
    <div id="leftpanel">
        <div id="innerleftpanel">
            <img id='arrowlp' src="images/arrowleft.png">
            <img class="iconleftpanel" data-allcities="true" src="images/home.png">
            <span class="iconheadersleftpanel">Города Влияния</span>
            <img class="iconleftpanel" data-allroutbtn="true" src="images/mapicon.png">
            <span class="iconheadersleftpanel">Маршруты</span>
        </div>
    </div>
    <div id="avatar">картинка персонажа</div>
    <div id="MAP">картинка персонажа</div>
    <div id="toppanel">картинка персонажа</div>
    <div id="clock"></div>
    <div id="RoutesWindow">
        <h1 id="routwndheader">Мои Маршруты</h1>
        <img src="images/krestikdlyokon.png" id="exitroutwindowbtn">
        <span class="tablerouteheader">Номер поезда</span>
        <span class="tablerouteheader">Откуда</span>
        <span class="tablerouteheader">Куда</span>
        <span class="tablerouteheader">Отправление</span>
        <span class="tablerouteheader">Прибытие</span>


    </div>
</div>
<script type="module">
    import {roaddifinitionclick,camera,volcanoobj3d, traingonormalization,scene,canvas,renderer,disigncontrolroadpoints, getnearestcity} from "./GameScript.js";
    import * as THREE from './js/three.js-master/build/three.module.js';

    let mouse = new THREE.Vector2();
    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / document.body.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / document.body.clientHeight ) * 2 + 1;
    }
    document.addEventListener( 'mousemove', onDocumentMouseMove, false );

    let arrowlp=document.getElementById('arrowlp');
    let innerleftpanel=document.getElementById('innerleftpanel');
    let arrowdp=document.getElementById('arrowdp');
    let mainpanel=document.getElementById('mainpanel');
    let mainflex=document.getElementById('mainflex');
    let citiesbtn=document.querySelector("[data-allroutbtn]");
    let routeswindow=document.getElementById('RoutesWindow');
    let exitrotesbtn=document.getElementById('exitroutwindowbtn');
    let addroad=document.getElementById('addroadbtn');

    let conterl=0;
    let conterd=0;

    arrowlp.onclick=(event)=>{
        conterl+=1;
        event.stopPropagation();
        if(conterl%2===0){
            arrowlp.classList.remove('rotatearrowback');
            arrowlp.classList.add('rotatearrowclass');
            innerleftpanel.classList.remove('openpanell');
            innerleftpanel.classList.add('hidepanell');
        }
        else {
            arrowlp.classList.remove('rotatearrowclass');
            arrowlp.classList.add('rotatearrowback');
            innerleftpanel.classList.remove('hidepanell');
            innerleftpanel.classList.add('openpanell');
        }
    };
    arrowdp.onclick=(event)=>{
        conterd+=1;
        event.stopPropagation();
        if(conterd%2===0){
            arrowdp.classList.remove('rotatearrowback');
            arrowdp.classList.add('rotatearrowclass');
            mainpanel.classList.remove('openpaneld');
            mainpanel.classList.add('hidepaneld');
        }
        else {
            arrowdp.classList.remove('rotatearrowclass');
            arrowdp.classList.add('rotatearrowback');
            mainpanel.classList.remove('hidepaneld');
            mainpanel.classList.add('openpaneld');
        }
    };
    citiesbtn.onclick=()=>{
       if (routeswindow.style.visibility==='hidden'){
           routeswindow.style.visibility='visible';
       }
       else {
           routeswindow.style.visibility='hidden';
       }
    };
    exitrotesbtn.onclick=()=>routeswindow.style.visibility='hidden';
    ////////////////////////////////////////////////////////////

     let allroadonmap=[];//все дороги нак арте
     let allroutes=new Map();//все маршруты(связанные куски дорог)
    let allroutespoints=new Map()//маршруты в виде серии точек
    let addroadactive=false;//если тру, то дорога перестанет липнуть к мышке и встанет на карту
    let road;//3d obj
    let axisforuser=new THREE.Vector3(0,1,0),angleforuser=0;//угол поворота дороги
    let accesstoput=true;//проверка на возможность размещения(пересечения с текстурами и тд)
    let cancelsdvig,idforallroutes=0;
    function putroad(e){//ставит дорогу там где она сейчас есть
        e.preventDefault();
        let nearestcity=getnearestcity(new THREE.Vector2(road.position.x, road.position.z));
        if((nearestcity.position.distanceTo(new THREE.Vector2(road.position.x,road.position.z))>Math.max(nearestcity.size.x,nearestcity.size.z)*1.5)&&(road.routerelative===undefined)) {//проверка на соседство с городом новой дороги
            accesstoput = false;
        }
        if (accesstoput===false){
            mainflex.insertAdjacentHTML("beforeend",
                  `<div id="alertt" style="position: relative;display: flex; justify-content: center; grid-column-start: 3; grid-column-end: 4; grid-row-start: 2; grid-row-end: 3;z-index: 1000">
                        <img style="width: 5vmax; height: 5vmax" src="./images/alert.png">
                         <img style="width: 40vmax; height: 10vmax" src="./images/image(9).png">
                   </div>

                  `
            );
            setTimeout(()=>{let alertt=document.getElementById('alertt'); alertt.remove()}, 3000);
            return;
        }
        if(road.newOrigin!==undefined) {
            let oldpos=road.children[0].getWorldPosition();
            road.children.forEach((value) => value.translateOnAxis((new THREE.Vector3()).copy(road.newOrigin).normalize(), road.newOrigin.length()));
            let newpos=road.children[0].getWorldPosition();
            let sdvig=new THREE.Vector3();
            sdvig.subVectors(oldpos,newpos);
            road.position.x+=sdvig.x;
            road.position.y+=sdvig.y;
            road.position.z+=sdvig.z;
        }
        addroadactive=false;
        cancelsdvig=true;
        allroadonmap.push(road);
        if(road.routerelative===undefined) {
            let _mas=[];
            allroutes.set(++idforallroutes, _mas);
            _mas.push(road);
            road.routerelative=idforallroutes;
            allroutespoints.set(idforallroutes,[]);
            disigncontrolroadpoints(road,allroutespoints.get(road.routerelative));
        }
        else{
            allroutes.get(road.routerelative).push(road);
            disigncontrolroadpoints(road,allroutespoints.get(road.routerelative));
        }
        document.removeEventListener("keydown", rotataroad);
    }
    function rotataroad(e){
        if (e.code==='Numpad4')
            road.rotateOnWorldAxis(new THREE.Vector3(0,1,0),Math.PI/36);
        if (e.code==='Numpad6')
            road.rotateOnWorldAxis(new THREE.Vector3(0,1,0),-Math.PI/36);
        let leftcorn1=road.getChildByName('leftcorner1');
        let rightcorner1=road.getChildByName('rightcorner1');
        let axis=new THREE.Vector3();
        axis.subVectors(leftcorn1.getWorldPosition(),rightcorner1.getWorldPosition());
        axisforuser=axis;
        if (e.code==='Numpad8'){
            road.rotateOnWorldAxis(axis.normalize(),Math.PI/36);
            angleforuser+= Math.PI/36;
        }
        if (e.code==='Numpad2') {
            road.rotateOnWorldAxis(axis.normalize(), -Math.PI / 36);
            angleforuser -= Math.PI / 36;
        }
        angleforuser=angleforuser%(2*Math.PI);
    }
    function f1(){
        canvas.addEventListener('mouseup',putroad,{capture:false});
        setTimeout(()=>{
            canvas.removeEventListener('mouseup',putroad,{capture:false});
        }, 500);
    }
    addroad.onclick=async ()=>{
        canvas.removeEventListener('mousedown',f1,{capture:false});
        cancelsdvig=false;
        canvas.addEventListener('mousedown',f1,{capture:false});
        if (addroadactive===false) {
            road = await roaddifinitionclick('./images/fullcorneredroadwithcontrol.glb');
            addroadactive=true;
            setTimeout(function adrod(){
                let raycaster = new THREE.Raycaster();
                raycaster.setFromCamera( mouse, camera );
                let intersects = raycaster.intersectObjects( [].concat(volcanoobj3d,allroadonmap), true);
                if ( intersects.length > 0 ) {
                    let p=intersects[0].point;
                   let nearroads=[];
                    for(let currod of allroadonmap){
                                let dist=p.distanceTo(currod.getWorldPosition());
                                if (dist<Math.max(road.width, road.length)) {//коэффициент для того чтобы найти ряждом какие чужие углы
                                    nearroads.push({currod, dist});
                                }
                    }
                        nearroads.sort((a,b)=>{
                        if (a.dist > b.dist) return 1;
                        if (a.dist < b.dist) return -1;
                        if (a.dist === b.dist) return 0;
                    });
                    if(cancelsdvig===false){
                    if(nearroads.length>0){
                        accesstoput=road.positionbytwocorners(nearroads[0].currod,p,axisforuser,angleforuser,allroadonmap);
                    }
                    else {
                        road.position.set(p.x, p.y+road.width/5, p.z);
                        road.routerelative=undefined;
                        accesstoput=true;
                        road.angleforuser=angleforuser;
                    }
                        }
                    document.addEventListener("keydown", rotataroad);
                }
                if(addroadactive)
                setTimeout(()=>adrod(),100);
            },100);
        }
        else {
            addroadactive=false;
            for (let i=road.children.length-1;i>=0;i--){
                road.children[i].material.dispose();
                road.children[i].geometry.dispose();
                road.remove( road.children[i]);
            }
            scene.remove(road);
            canvas.removeEventListener('mouseup',putroad,{capture:false});
            document.removeEventListener("keydown", rotataroad);
        }
    };

</script>
<script type="module">//скрипт часов
    import {clock, traingo} from "./GameScript.js";

    let clockelem=document.getElementById('clock');

    let formatter = new Intl.DateTimeFormat("ru", {
        year: "numeric",
        month: "long",
        day: "numeric",
        hour:'numeric',
        minute:'numeric'
    });

    setTimeout(function clockgo() {
        clock.setTime(clock.getTime()+3600*1000);
        clockelem.innerHTML=(formatter.format(clock));
        traingo();
        setTimeout(clockgo, 1000);
    },1000);

</script>
<script id='mainscenescript' type="module">
    import * as THREE from './js/three.js-master/build/three.module.js';
    import {OrbitControls} from './js/three.js-master/examples/jsm/controls/OrbitControls.js';
    import {resizerenderertotal} from "./js/usefuljs.js";
    import {OBJLoader2} from './js/three.js-master/examples/jsm/loaders/OBJLoader2.js';
    import {Vector3} from "./js/three.js-master/src/math/Vector3.js";
    import {Plane} from "./js/three.js-master/src/math/Plane.js";
    import {traingo,train3dobj,volcanoobj3d,canvas,scene,camera,renderer,controls,light,MTLlod,loader,cubemaploader,cubetextture,roaddifinitionclick} from"./GameScript.js";
    {
         //трекбол не работает когда камера на оси у, флацй надо передавать 12 в апдейт дела
        let curbtns={};
        canvas.addEventListener('keydown',(event)=>{
            curbtns[event.code]=true;
            movecamera(event)}
        , false);
        canvas.addEventListener('keyup', (event)=>{
                delete curbtns[event.code];
                movecamera(event)}
            , false);
        function movecamera(event) {             //https://learn.javascript.ru/task/check-sync-keydown доделать чтобы по диагонали
            let z = controls.target.z;
            let y = controls.target.y;
            let x = controls.target.x;
            let camz = camera.position.z;
            let camy = camera.position.y;
            let camx = camera.position.x;
            let arvect = camera.getWorldDirection();
            arvect = arvect.normalize().multiplyScalar(10000);

            if (curbtns.KeyW && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyW && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                controls.target.set(x + arvect.x, y, z + arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;;
            }
            else if(curbtns.KeyS && curbtns.KeyA){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyD){
                arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 4);
                camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                controls.target.set(x - arvect.x, y, z - arvect.z);
                camera.updateProjectionMatrix();
                controls.update();
                return;
            }
            else if(curbtns.KeyS && curbtns.KeyW){
                return;
            }
            else if(curbtns.KeyA && curbtns.KeyD){
                return;
            }
            switch (event.code) {
                case 'KeyW':
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyS':
                    camera.position.set(camx - arvect.x, camy, camz - arvect.z);
                    controls.target.set(x - arvect.x, y, z - arvect.z);
                    break;
                case  'KeyD':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), -Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
                case  'KeyA':
                    arvect.applyAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
                    camera.position.set(camx + arvect.x, camy, camz + arvect.z);
                    controls.target.set(x + arvect.x, y, z + arvect.z);
                    break;
            }
            camera.updateProjectionMatrix();
            controls.update();
        }
    }//контролы и  камера
    requestAnimationFrame( render );

    function render() {
        resizerenderertotal(renderer, camera);
        controls.update();
        renderer.render( scene, camera );
        requestAnimationFrame( render);
    }
</script>

</body>
</html>